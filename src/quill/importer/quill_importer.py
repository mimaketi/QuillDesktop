"""
Importer for Quill Archives
"""

import tarfile
import struct
import os


from quill.importer.base import ImporterBase, QuillImporterError


class QuillPage(object):
    # Purely arbitrary
    # A line-width of 0.003 gives a good visual approximation to Quill's pen thickness of 5
    pen_scale_factor = float(5.0/0.003)

    def __init__(self, page_file, blob_loader):
        self._blob_loader = blob_loader
        fp = self.fp = page_file
        self.version = struct.unpack(">i", fp.read(4))
        if self.version != (6,):
            raise QuillImporterError('wrong page version')
        nbytes = struct.unpack(">h", fp.read(2))
        self.uuid = fp.read(36)
        self.tsversion = struct.unpack(">i", fp.read(4))
        if self.tsversion != (1,):
            raise QuillImporterError('wrong tag set version')
        self.ntags = struct.unpack(">i", fp.read(4))
        
        # If we have tags
        self.tags = []
        for x in xrange(self.ntags[0]):
            self.tversion = struct.unpack(">i", fp.read(4))
            if self.tversion != (1,):
                raise QuillImporterError('wrong tag version')
            nbytes = struct.unpack(">h", fp.read(2))
            tag = {}
            tag["tag"] = fp.read(nbytes[0]).decode("utf-8")
            tag["autogenerated"] = struct.unpack(">?", fp.read(1))[0]
            tag["ctime"] = struct.unpack(">q", fp.read(8))[0]
            dummy = struct.unpack(">q", fp.read(8))
            self.tags.append(tag)
        
        foo = struct.unpack(">i", fp.read(4))
        foo = struct.unpack(">i", fp.read(4))
        
        self.paper_type = struct.unpack(">i", fp.read(4))
        self.nimages = struct.unpack(">i", fp.read(4))
        self.images = [ self.read_image() for i in xrange(self.nimages[0]) ]
        dummy = struct.unpack(">i", fp.read(4))
        if dummy != (0,):
            raise QuillImporterError('out of sync')
        self.read_only = struct.unpack(">?", fp.read(1))
        self.aspect_ratio = struct.unpack(">f", fp.read(4))[0]
        self.nstrokes = struct.unpack(">i", fp.read(4))
        self.strokes = [ self.read_stroke() for i in xrange(self.nstrokes[0]) ]
        self.nlines = struct.unpack(">i", fp.read(4))
        self.lines = [ self.read_line() for i in xrange(self.nlines[0]) ]
        dummy = struct.unpack(">i", fp.read(4))
        if dummy != (0,):
            raise QuillImporterError('out of sync')
        # self.ntext = struct.unpack(">i", fp.read(4))
        
    def read_image(self):
        fp = self.fp
        version = struct.unpack(">i", fp.read(4))
        if version != (1,):
            raise QuillImporterError('wrong image version')
        uuid_nbytes = struct.unpack(">h", fp.read(2))
        uuid = fp.read(36)
        top_left = struct.unpack(">f", fp.read(4))
        top_right = struct.unpack(">f", fp.read(4))
        bottom_left = struct.unpack(">f", fp.read(4))
        bottom_right = struct.unpack(">f", fp.read(4))
        constrain_aspect = struct.unpack(">?", fp.read(1))
        from quill.image import Image
        return Image(uuid, 
                     top_left[0], top_right[0], bottom_left[0], bottom_right[0], 
                     constrain_aspect[0], self._blob_loader.get(uuid))

    def read_stroke(self):
        fp = self.fp
        version = struct.unpack(">i", fp.read(4))
        if version != (2,):
            raise QuillImporterError('wrong stroke version')
        pen_color = struct.unpack(">I", fp.read(4))
        red = (pen_color[0] >> 16) & 0xFF
        green = (pen_color[0] >> 8) & 0xFF
        blue = pen_color[0] & 0xFF
        thickness = struct.unpack(">i", fp.read(4))
        toolint = struct.unpack(">i", fp.read(4))
        fountain_pen = (toolint == (0,))
        N = struct.unpack(">i", fp.read(4))
        points = []
        for i in xrange(N[0]):
            x = struct.unpack(">f", fp.read(4))
            y = struct.unpack(">f", fp.read(4))
            p = struct.unpack(">f", fp.read(4))
            points.append((x[0], y[0], p[0]))
        from quill.stroke import Stroke
        return Stroke(fountain_pen, thickness[0], red, green, blue, points)

    def read_line(self):
        fp = self.fp
        version = struct.unpack(">i", fp.read(4))
        if version != (1,):
            raise QuillImporterError('wrong line version')
        pen_color = struct.unpack(">I", fp.read(4))
        red = (pen_color[0] >> 16) & 0xFF
        green = (pen_color[0] >> 8) & 0xFF
        blue = pen_color[0] & 0xFF
        thickness = struct.unpack(">i", fp.read(4))
        toolint = struct.unpack(">i", fp.read(4))
        if toolint != (5,):
            raise QuillImporterError('wrong line tool')
        xy = struct.unpack(">ffff", fp.read(4*4))
        from quill.line import Line
        return Line(thickness[0], red, green, blue, xy[0], xy[1], xy[2], xy[3])

class QuillIndex(object):

    def __init__(self, index_file):
        fp = index_file
        self.version = struct.unpack(">i", fp.read(4))
        if self.version != (4,):
            raise QuillImporterError('wrong page version')
        self.npages = struct.unpack(">i", fp.read(4))
        self.page_uuids = []
        for x in xrange(self.npages[0]):
            nbytes = struct.unpack(">h", fp.read(2))
            u = fp.read(36)
            self.page_uuids.append(u)
        self.currentPage = struct.unpack(">i", fp.read(4))
        nbytes = struct.unpack(">h", fp.read(2))
        self.title = fp.read(nbytes[0])
        self.ctime = struct.unpack(">q", fp.read(8))
        self.mtime = struct.unpack(">q", fp.read(8))
        nbytes = struct.unpack(">h", fp.read(2))
        self.uuid = fp.read(36)

    def __repr__(self):
        s =  'File version: '+str(self.version)+'\n'
        s += 'Title: ' + self.title + '\n'
        s += 'ctime: ' + str(self.ctime) + '\n'
        s += 'mtime: ' + str(self.mtime) + '\n'
        for i,p in enumerate(self.page_uuids):
            s += 'page ' + str(i) + ': ' + p + '\n'
        return s

class QuillBlob(object):
    """
    Loader for contained binary objects (e.g. images)
    """
    def __init__(self, tar):
        self._tar = tar

    def get(self, uuid):
        """
        Return the object with given uuid
        """
        fileinfo = self._find_uuid(uuid)
        f = self._tar.extractfile(fileinfo)
        try:
            data = f.read()
            return data
        except IOError:
            raise QuillImporterError('failed to read binary object')
        finally:
            f.close()

    def _find_uuid(self, uuid):
        for f in self._tar.getmembers():
            name = os.path.split(f.name)[-1]
            if name.startswith(uuid):
                return f
        raise QuillImporterError('binary object missing from Quill file')



class QuillImporter(ImporterBase):
    
    def __init__(self, quill_filename):
        self._filename = quill_filename
        with tarfile.open(self._filename, "r") as t:
            self._open_quill_archive(t)

    def _open_quill_archive(self, t):
        index_files = [ t.extractfile(f) for f in t.getmembers() 
                        if f.name.endswith('index.quill_data') ]
        if len(index_files) != 1:
            raise QuillImporterError('Not a Quill file, missing index')
        self._index = q = QuillIndex(index_files[0])
        notebook_dir = os.path.split(index_files[0].name)[0]
        self._page_filenames = [notebook_dir+'/page_'+page_uuid+'.quill_data'
                                for page_uuid in q.page_uuids ]

    def uuid(self):
        return self._index.uuid

    def title(self):
        return self._index.title

    def mtime_millis(self):
        return self._index.mtime[0]

    def ctime_millis(self):
        return self._index.ctime[0]

    def n_pages(self):
        return self._index.npages[0]

    def get_page(self, n):
        """
        Return the n-th page.
        """
        page_filename = self._page_filenames[n]
        with tarfile.open(self._filename, "r") as t:
            page_file = t.extractfile(page_filename)
            qp = QuillPage(page_file, QuillBlob(t))
        from quill.page import Page
        return Page(n, qp.uuid, qp.aspect_ratio, qp.strokes, qp.lines, qp.images)

